# ğŸ§­ **SOP: Understanding How Kubernetes Runs Containers**

---

## ğŸ¯ **Objective**

To explain how Kubernetes runs containers step-by-step, what each layer (Pod, ReplicaSet, Deployment, Service) does, and why these abstractions are needed â€” even though we could technically â€œrun a container directly.â€

---

## ğŸ§© **1. Why So Many Layers?**

Yes â€” we *can* run a container directly, but Kubernetes is designed for **scalable**, **self-healing**, and **managed** workloads across **clusters of machines** â€” not just a single host.

Letâ€™s understand what each layer adds on top of a simple container:

---

### ğŸ§± 1. **Container**

* The smallest unit that actually runs your application.
* Example: `docker run nginx`
* Works fine *locally*, but:

  * No self-healing if the container crashes.
  * No scaling (you must run multiple manually).
  * No internal/external service discovery.

ğŸ‘‰ *So Kubernetes doesnâ€™t manage containers directly.*

---

### ğŸ§© 2. **Pod**

* Kubernetesâ€™ smallest deployable unit.
* A **Pod** is a logical wrapper around one or more containers that must run together (e.g., main app + helper sidecar).
* All containers in a Pod:

  * Share the same **network namespace** (same IP)
  * Can share **storage volumes**
  * Are scheduled together on the same **node**

**Why not just containers?**
â†’ Because Pods give Kubernetes a unified way to manage apps and apply policies, networking, and restarts â€” even if there are multiple containers.

---

### âš™ï¸ 3. **ReplicaSet**

* Ensures a specific number of Pod replicas are always running.
* Example: if you want 3 Pods and 1 crashes, ReplicaSet immediately creates a new one.
* Supports:

  * Self-healing
  * Horizontal scaling
  * High availability

**You could run Pods directly**, but youâ€™d have to manually recreate them â€” not ideal for production.

---

### ğŸš€ 4. **Deployment**

* The most commonly used Kubernetes object for running stateless apps.
* A Deployment manages **ReplicaSets** automatically.
* It enables:

  * Rolling updates (zero-downtime deployments)
  * Rollbacks to previous versions
  * Declarative configuration

**Example:**
When you say, â€œrun 3 replicas of nginx:latest,â€ Kubernetes:

> Deployment â†’ creates ReplicaSet â†’ creates Pods â†’ runs Containers

---

### ğŸŒ 5. **Service**

* A **Service** exposes your Pods to the network.
* Since Pods are **ephemeral** (they die and recreate with new IPs), you canâ€™t depend on Pod IPs.
* A Service provides:

  * A **stable IP address** and **DNS name**
  * **Load balancing** between Pods
  * **Service discovery**

---

## ğŸ§± **2. Hierarchical Structure (Tree Diagram)**

```
Deployment
 â””â”€â”€ ReplicaSet
      â””â”€â”€ Pod
           â””â”€â”€ Container
Service
 â””â”€â”€ Targets Pods (via label selectors)
```

---

## ğŸ§­ **3. Architecture Diagram (Text View)**

```
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚     Deployment     â”‚
               â”‚ (Declarative mgmt) â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚     ReplicaSet     â”‚
               â”‚ (Ensures # of Pods)â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚        Pod         â”‚
               â”‚ (Runs containers)  â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚     Container      â”‚
               â”‚ (Your app/runtime) â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–²
                        â”‚
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚      Service       â”‚
               â”‚ (Exposes the Pods) â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš™ï¸ **4. Workflow Summary**

| **Step** | **Kubernetes Object** | **What Happens**                                | **Outcome**                         |
| -------- | --------------------- | ----------------------------------------------- | ----------------------------------- |
| 1        | **Deployment**        | You define your appâ€™s image, replicas, etc.     | Kubernetes creates a ReplicaSet     |
| 2        | **ReplicaSet**        | Ensures the required number of Pods are running | Recreates Pods if needed            |
| 3        | **Pod**               | Wraps and runs your container(s)                | The app starts running              |
| 4        | **Service**           | Exposes the app to internal/external traffic    | Stable endpoint (IP/DNS) for access |

---

## ğŸ§° **5. Example YAML Configuration**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: NodePort
```

âœ… **This YAML creates:**

* A **Deployment** with 3 Nginx Pods.
* A **ReplicaSet** managed by the Deployment.
* A **Service** exposing those Pods via a NodePort.

---

## ğŸ”„ **6. Lifecycle Flow**

```
[ You apply YAML / kubectl apply ]
              â†“
        Kubernetes API Server
              â†“
        Deployment Created
              â†“
        ReplicaSet Created
              â†“
        Pods Scheduled on Nodes
              â†“
        Containers Started
              â†“
        Service Exposes Pods
```

---

## ğŸ§  **7. Why Kubernetes Uses These Layers**

| **Layer**      | **Problem Solved**         | **Value Added**                |
| -------------- | -------------------------- | ------------------------------ |
| **Container**  | Runs an app process        | Portable, isolated runtime     |
| **Pod**        | Combine related containers | Shared networking & lifecycle  |
| **ReplicaSet** | Ensure number of Pods      | Self-healing, scaling          |
| **Deployment** | Manage ReplicaSets         | Declarative updates, rollbacks |
| **Service**    | Expose Pods reliably       | Stable IP/DNS, load balancing  |

---

## ğŸ§© **8. Analogy: Building a House**

| **Kubernetes Object** | **Analogy**                              | **Purpose**                      |
| --------------------- | ---------------------------------------- | -------------------------------- |
| Container             | The appliances (your app, like a fridge) | The thing doing the actual work  |
| Pod                   | A room in the house                      | Holds and connects appliances    |
| ReplicaSet            | The number of identical rooms            | Ensures capacity & redundancy    |
| Deployment            | The building plan                        | Controls upgrades, versions      |
| Service               | The address and mailbox                  | Allows others to find your house |

---

## ğŸ§­ **9. SOP â€“ Step-by-Step Execution**

| **Step No.** | **Action**            | **Command**                                                  | **Expected Result**             |
| ------------ | --------------------- | ------------------------------------------------------------ | ------------------------------- |
| 1            | Create a Deployment   | `kubectl create deployment nginx --image=nginx --replicas=3` | ReplicaSet and Pods are created |
| 2            | Check Pods            | `kubectl get pods`                                           | 3 Pods in Running state         |
| 3            | Expose the Deployment | `kubectl expose deployment nginx --port=80 --type=NodePort`  | Service created                 |
| 4            | View Services         | `kubectl get svc`                                            | NodePort/ClusterIP assigned     |
| 5            | Access App            | `curl <NodeIP>:<NodePort>`                                   | Nginx page loads                |
| 6            | Scale App             | `kubectl scale deploy nginx --replicas=5`                    | 5 Pods running                  |
| 7            | Update App            | `kubectl set image deploy nginx nginx=nginx:1.27`            | Rolling update occurs           |
| 8            | Rollback              | `kubectl rollout undo deploy nginx`                          | Returns to previous version     |

---

## ğŸ§© **10. Summary Table**

| **Goal**            | **Kubernetes Object** | **Example**                     |
| ------------------- | --------------------- | ------------------------------- |
| Run an app          | **Container**         | Docker / Nginx                  |
| Manage runtime      | **Pod**               | `kubectl run`                   |
| Ensure availability | **ReplicaSet**        | `kubectl get rs`                |
| Handle updates      | **Deployment**        | `kubectl rollout status deploy` |
| Expose app          | **Service**           | `kubectl expose deploy`         |

---

## ğŸ **11. Key Takeaway**

> Kubernetes layers exist to abstract complexity step by step â€”
> from running *one container* â†’ to managing *hundreds* of resilient, scalable, discoverable applications across clusters.

---

