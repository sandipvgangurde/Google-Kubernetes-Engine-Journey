# 🧭 **SOP: Understanding How Kubernetes Runs Containers**

---

## 🎯 **Objective**

To explain how Kubernetes runs containers step-by-step, what each layer (Pod, ReplicaSet, Deployment, Service) does, and why these abstractions are needed — even though we could technically “run a container directly.”

---

## 🧩 **1. Why So Many Layers?**

Yes — we *can* run a container directly, but Kubernetes is designed for **scalable**, **self-healing**, and **managed** workloads across **clusters of machines** — not just a single host.

Let’s understand what each layer adds on top of a simple container:

---

### 🧱 1. **Container**

* The smallest unit that actually runs your application.
* Example: `docker run nginx`
* Works fine *locally*, but:

  * No self-healing if the container crashes.
  * No scaling (you must run multiple manually).
  * No internal/external service discovery.

👉 *So Kubernetes doesn’t manage containers directly.*

---

### 🧩 2. **Pod**

* Kubernetes’ smallest deployable unit.
* A **Pod** is a logical wrapper around one or more containers that must run together (e.g., main app + helper sidecar).
* All containers in a Pod:

  * Share the same **network namespace** (same IP)
  * Can share **storage volumes**
  * Are scheduled together on the same **node**

**Why not just containers?**
→ Because Pods give Kubernetes a unified way to manage apps and apply policies, networking, and restarts — even if there are multiple containers.

---

### ⚙️ 3. **ReplicaSet**

* Ensures a specific number of Pod replicas are always running.
* Example: if you want 3 Pods and 1 crashes, ReplicaSet immediately creates a new one.
* Supports:

  * Self-healing
  * Horizontal scaling
  * High availability

**You could run Pods directly**, but you’d have to manually recreate them — not ideal for production.

---

### 🚀 4. **Deployment**

* The most commonly used Kubernetes object for running stateless apps.
* A Deployment manages **ReplicaSets** automatically.
* It enables:

  * Rolling updates (zero-downtime deployments)
  * Rollbacks to previous versions
  * Declarative configuration

**Example:**
When you say, “run 3 replicas of nginx:latest,” Kubernetes:

> Deployment → creates ReplicaSet → creates Pods → runs Containers

---

### 🌐 5. **Service**

* A **Service** exposes your Pods to the network.
* Since Pods are **ephemeral** (they die and recreate with new IPs), you can’t depend on Pod IPs.
* A Service provides:

  * A **stable IP address** and **DNS name**
  * **Load balancing** between Pods
  * **Service discovery**

---

## 🧱 **2. Hierarchical Structure (Tree Diagram)**

```
Deployment
 └── ReplicaSet
      └── Pod
           └── Container
Service
 └── Targets Pods (via label selectors)
```

---

## 🧭 **3. Architecture Diagram (Text View)**

```
               ┌────────────────────┐
               │     Deployment     │
               │ (Declarative mgmt) │
               └────────┬───────────┘
                        │
                        ▼
               ┌────────────────────┐
               │     ReplicaSet     │
               │ (Ensures # of Pods)│
               └────────┬───────────┘
                        │
                        ▼
               ┌────────────────────┐
               │        Pod         │
               │ (Runs containers)  │
               └────────┬───────────┘
                        │
                        ▼
               ┌────────────────────┐
               │     Container      │
               │ (Your app/runtime) │
               └────────────────────┘
                        ▲
                        │
               ┌────────────────────┐
               │      Service       │
               │ (Exposes the Pods) │
               └────────────────────┘
```

---

## ⚙️ **4. Workflow Summary**

| **Step** | **Kubernetes Object** | **What Happens**                                | **Outcome**                         |
| -------- | --------------------- | ----------------------------------------------- | ----------------------------------- |
| 1        | **Deployment**        | You define your app’s image, replicas, etc.     | Kubernetes creates a ReplicaSet     |
| 2        | **ReplicaSet**        | Ensures the required number of Pods are running | Recreates Pods if needed            |
| 3        | **Pod**               | Wraps and runs your container(s)                | The app starts running              |
| 4        | **Service**           | Exposes the app to internal/external traffic    | Stable endpoint (IP/DNS) for access |

---

## 🧰 **5. Example YAML Configuration**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: NodePort
```

✅ **This YAML creates:**

* A **Deployment** with 3 Nginx Pods.
* A **ReplicaSet** managed by the Deployment.
* A **Service** exposing those Pods via a NodePort.

---

## 🔄 **6. Lifecycle Flow**

```
[ You apply YAML / kubectl apply ]
              ↓
        Kubernetes API Server
              ↓
        Deployment Created
              ↓
        ReplicaSet Created
              ↓
        Pods Scheduled on Nodes
              ↓
        Containers Started
              ↓
        Service Exposes Pods
```

---

## 🧠 **7. Why Kubernetes Uses These Layers**

| **Layer**      | **Problem Solved**         | **Value Added**                |
| -------------- | -------------------------- | ------------------------------ |
| **Container**  | Runs an app process        | Portable, isolated runtime     |
| **Pod**        | Combine related containers | Shared networking & lifecycle  |
| **ReplicaSet** | Ensure number of Pods      | Self-healing, scaling          |
| **Deployment** | Manage ReplicaSets         | Declarative updates, rollbacks |
| **Service**    | Expose Pods reliably       | Stable IP/DNS, load balancing  |

---

## 🧩 **8. Analogy: Building a House**

| **Kubernetes Object** | **Analogy**                              | **Purpose**                      |
| --------------------- | ---------------------------------------- | -------------------------------- |
| Container             | The appliances (your app, like a fridge) | The thing doing the actual work  |
| Pod                   | A room in the house                      | Holds and connects appliances    |
| ReplicaSet            | The number of identical rooms            | Ensures capacity & redundancy    |
| Deployment            | The building plan                        | Controls upgrades, versions      |
| Service               | The address and mailbox                  | Allows others to find your house |

---

## 🧭 **9. SOP – Step-by-Step Execution**

| **Step No.** | **Action**            | **Command**                                                  | **Expected Result**             |
| ------------ | --------------------- | ------------------------------------------------------------ | ------------------------------- |
| 1            | Create a Deployment   | `kubectl create deployment nginx --image=nginx --replicas=3` | ReplicaSet and Pods are created |
| 2            | Check Pods            | `kubectl get pods`                                           | 3 Pods in Running state         |
| 3            | Expose the Deployment | `kubectl expose deployment nginx --port=80 --type=NodePort`  | Service created                 |
| 4            | View Services         | `kubectl get svc`                                            | NodePort/ClusterIP assigned     |
| 5            | Access App            | `curl <NodeIP>:<NodePort>`                                   | Nginx page loads                |
| 6            | Scale App             | `kubectl scale deploy nginx --replicas=5`                    | 5 Pods running                  |
| 7            | Update App            | `kubectl set image deploy nginx nginx=nginx:1.27`            | Rolling update occurs           |
| 8            | Rollback              | `kubectl rollout undo deploy nginx`                          | Returns to previous version     |

---

## 🧩 **10. Summary Table**

| **Goal**            | **Kubernetes Object** | **Example**                     |
| ------------------- | --------------------- | ------------------------------- |
| Run an app          | **Container**         | Docker / Nginx                  |
| Manage runtime      | **Pod**               | `kubectl run`                   |
| Ensure availability | **ReplicaSet**        | `kubectl get rs`                |
| Handle updates      | **Deployment**        | `kubectl rollout status deploy` |
| Expose app          | **Service**           | `kubectl expose deploy`         |

---

## 🏁 **11. Key Takeaway**

> Kubernetes layers exist to abstract complexity step by step —
> from running *one container* → to managing *hundreds* of resilient, scalable, discoverable applications across clusters.

---

