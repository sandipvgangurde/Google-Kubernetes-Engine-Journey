# ğŸ•¹ï¸ **Kubernetes - Pause & Resume Deployments**

**ğŸ¯ Description:** Implement Kubernetes - Pause & Resume Deployments

---

## ğŸ§© **Step-00: Introduction**

### ğŸ’¡ **Why do we need Pausing & Resuming Deployments?**

When you want to make **multiple updates** (like changing the image, updating resource limits, or modifying environment variables), you can **pause the deployment**, make all your edits safely, and then **resume** it to apply everything at once.

ğŸ’¬ **Althea Comment:**
Pausing prevents unnecessary intermediate rollouts.
For example â€” if you update the image, resource limits, and replicas one after another without pausing, Kubernetes will trigger a new rollout for each change. That wastes time and can cause temporary instability.

---

Weâ€™ll now **update the Application Version from V3 â†’ V4** to learn how Pause & Resume works.

---

## âš™ï¸ **Step-01: Pausing & Resuming Deployments**

### ğŸ” **Check current State of Deployment & Application**

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**ğŸ§  Observation:**
Make a note of the **last version number** (revision ID). Youâ€™ll use this later to confirm if a new rollout was triggered or not.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**ğŸ§  Observation:**
Count the number of **ReplicaSets** currently available. This helps verify later if a new one gets created after the update.

---

```bash
# Access the Application 
http://<External-IP-from-get-service-output>
```

**ğŸ§  Observation:**
Note the **current application version** displayed â€” should be **V3** before you start.

---

### â¸ï¸ **Pause Deployment and Make Two Changes**

```bash
# Pause the Deployment
kubectl rollout pause deployment/<Deployment-Name>
kubectl rollout pause deployment/my-first-deployment
```

ğŸ’¬ **Althea Comment:**
This freezes the rollout mechanism â€” Kubernetes wonâ€™t automatically start updating Pods even if you modify specs.
Basically, youâ€™re locking the current ReplicaSet until youâ€™re done making all your planned changes.

---

```bash
# Update Deployment - Application Version from V3 to V4
kubectl set image deployment/my-first-deployment kubenginx=stacksimplify/kubenginx:4.0.0 
```

ğŸ’¬ **Althea Comment:**
Even though you updated the image, no rollout will start yet because the deployment is paused.
Kubernetes will just store the change internally.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**ğŸ§  Observation:**
You should **not** see a new revision created.
The version count and the **last revision number** must remain the same â€” proving that pausing actually worked.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**ğŸ§  Observation:**
Still the same number of ReplicaSets as before â€” confirming that Kubernetes hasnâ€™t created a new one yet.

---

```bash
# Make one more change: set limits to our container
kubectl set resources deployment/my-first-deployment -c=kubenginx --limits=cpu=20m,memory=30Mi
```

ğŸ’¬ **Althea Comment:**
Now youâ€™ve made two configuration changes â€” **image + resource limits** â€” without triggering two separate rollouts.
If the deployment wasnâ€™t paused, youâ€™d have wasted time with two rollout cycles.

---

### â–¶ï¸ **Resume Deployment**

```bash
# Resume the Deployment
kubectl rollout resume deployment/my-first-deployment
```

ğŸ’¬ **Althea Comment:**
Once you resume, Kubernetes immediately applies all the pending changes in one **combined rollout**.
It now creates a **new ReplicaSet** with the V4 image and new resource limits.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**ğŸ§  Observation:**
You should now see a **new version** created (e.g., revision +1 from your earlier note).

---

```bash
# Update REVISION CHANGE-CAUSE
kubectl annotate deployment/my-first-deployment kubernetes.io/change-cause="Deployment PAUSE RESUME Demo - App Version 4.0.0 "
```

ğŸ’¬ **Althea Comment:**
Always annotate your rollouts with a **clear change-cause**.
It helps during debugging â€” especially when multiple people manage the same cluster.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment
```

**ğŸ§  Observation:**
Verify that the **annotation** appears in the history â€” itâ€™s a great way to track who changed what and why.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**ğŸ§  Observation:**
You should now see a **new ReplicaSet** added for version 4.0.0 â€” confirming that your paused changes were applied successfully.

---

```bash
# Get Load Balancer IP
kubectl get svc
```

```bash
# Access the Application 
http://<External-IP-from-get-service-output>
```

**ğŸ§  Observation:**
The page should show **Application Version: V4**.
âœ… Youâ€™ve successfully updated from V3 â†’ V4 using Pause and Resume.

---

## ğŸ§¹ **Step-02: Clean-Up**

```bash
# Delete Deployment
kubectl delete deployment my-first-deployment

# Delete Service
kubectl delete svc my-first-deployment-service

# Get all Objects from Kubernetes default namespace
kubectl get all
```

ğŸ’¬ **Althea Comment:**
Always clean up lab resources. It prevents namespace clutter and avoids unnecessary billing in managed clusters like GKE or EKS.

---
