# 🕹️ **Kubernetes - Pause & Resume Deployments**

**🎯 Description:** Implement Kubernetes - Pause & Resume Deployments

---

## 🧩 **Step-00: Introduction**

### 💡 **Why do we need Pausing & Resuming Deployments?**

When you want to make **multiple updates** (like changing the image, updating resource limits, or modifying environment variables), you can **pause the deployment**, make all your edits safely, and then **resume** it to apply everything at once.

💬 **Althea Comment:**
Pausing prevents unnecessary intermediate rollouts.
For example — if you update the image, resource limits, and replicas one after another without pausing, Kubernetes will trigger a new rollout for each change. That wastes time and can cause temporary instability.

---

We’ll now **update the Application Version from V3 → V4** to learn how Pause & Resume works.

---

## ⚙️ **Step-01: Pausing & Resuming Deployments**

### 🔍 **Check current State of Deployment & Application**

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**🧠 Observation:**
Make a note of the **last version number** (revision ID). You’ll use this later to confirm if a new rollout was triggered or not.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**🧠 Observation:**
Count the number of **ReplicaSets** currently available. This helps verify later if a new one gets created after the update.

---

```bash
# Access the Application 
http://<External-IP-from-get-service-output>
```

**🧠 Observation:**
Note the **current application version** displayed — should be **V3** before you start.

---

### ⏸️ **Pause Deployment and Make Two Changes**

```bash
# Pause the Deployment
kubectl rollout pause deployment/<Deployment-Name>
kubectl rollout pause deployment/my-first-deployment
```

💬 **Althea Comment:**
This freezes the rollout mechanism — Kubernetes won’t automatically start updating Pods even if you modify specs.
Basically, you’re locking the current ReplicaSet until you’re done making all your planned changes.

---

```bash
# Update Deployment - Application Version from V3 to V4
kubectl set image deployment/my-first-deployment kubenginx=stacksimplify/kubenginx:4.0.0 
```

💬 **Althea Comment:**
Even though you updated the image, no rollout will start yet because the deployment is paused.
Kubernetes will just store the change internally.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**🧠 Observation:**
You should **not** see a new revision created.
The version count and the **last revision number** must remain the same — proving that pausing actually worked.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**🧠 Observation:**
Still the same number of ReplicaSets as before — confirming that Kubernetes hasn’t created a new one yet.

---

```bash
# Make one more change: set limits to our container
kubectl set resources deployment/my-first-deployment -c=kubenginx --limits=cpu=20m,memory=30Mi
```

💬 **Althea Comment:**
Now you’ve made two configuration changes — **image + resource limits** — without triggering two separate rollouts.
If the deployment wasn’t paused, you’d have wasted time with two rollout cycles.

---

### ▶️ **Resume Deployment**

```bash
# Resume the Deployment
kubectl rollout resume deployment/my-first-deployment
```

💬 **Althea Comment:**
Once you resume, Kubernetes immediately applies all the pending changes in one **combined rollout**.
It now creates a **new ReplicaSet** with the V4 image and new resource limits.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment  
```

**🧠 Observation:**
You should now see a **new version** created (e.g., revision +1 from your earlier note).

---

```bash
# Update REVISION CHANGE-CAUSE
kubectl annotate deployment/my-first-deployment kubernetes.io/change-cause="Deployment PAUSE RESUME Demo - App Version 4.0.0 "
```

💬 **Althea Comment:**
Always annotate your rollouts with a **clear change-cause**.
It helps during debugging — especially when multiple people manage the same cluster.

---

```bash
# Check the Rollout History of a Deployment
kubectl rollout history deployment/my-first-deployment
```

**🧠 Observation:**
Verify that the **annotation** appears in the history — it’s a great way to track who changed what and why.

---

```bash
# Get list of ReplicaSets
kubectl get rs
```

**🧠 Observation:**
You should now see a **new ReplicaSet** added for version 4.0.0 — confirming that your paused changes were applied successfully.

---

```bash
# Get Load Balancer IP
kubectl get svc
```

```bash
# Access the Application 
http://<External-IP-from-get-service-output>
```

**🧠 Observation:**
The page should show **Application Version: V4**.
✅ You’ve successfully updated from V3 → V4 using Pause and Resume.

---

## 🧹 **Step-02: Clean-Up**

```bash
# Delete Deployment
kubectl delete deployment my-first-deployment

# Delete Service
kubectl delete svc my-first-deployment-service

# Get all Objects from Kubernetes default namespace
kubectl get all
```

💬 **Althea Comment:**
Always clean up lab resources. It prevents namespace clutter and avoids unnecessary billing in managed clusters like GKE or EKS.

---
